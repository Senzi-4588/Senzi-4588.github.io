<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Centos+GitHub+域名搭建</title>
      <link href="/2019/10/31/centos-github-yu-ming-da-jian/"/>
      <url>/2019/10/31/centos-github-yu-ming-da-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="Centos下搭建Hexo-github-域名"><a href="#Centos下搭建Hexo-github-域名" class="headerlink" title="Centos下搭建Hexo+github+域名"></a>Centos下搭建Hexo+github+域名</h2><h2 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装Node.js</h2><p>   1.下载</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v9.3.0/node-v9.3.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>   2.解压</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tar -xvJf node-v9.3.0-linux-x64.tar.xz</span><br><span class="line"></span><br><span class="line">文件就被解压到当前文件夹下了，然后移动</span><br><span class="line"></span><br><span class="line">mv  node-v9.3.0-linux-x64  node</span><br><span class="line"></span><br><span class="line">mv  node  /usr/local/</span><br></pre></td></tr></table></figure>   <a id="more"></a><p>   3.配置环境变量</p><h3 id="编辑-etc-profile-使用vim"><a href="#编辑-etc-profile-使用vim" class="headerlink" title="编辑 /etc/profile (使用vim)"></a>编辑 /etc/profile (使用vim)</h3><p>   vim /etc/profile</p><h3 id="在底部添加-PATH-变量"><a href="#在底部添加-PATH-变量" class="headerlink" title="在底部添加 PATH 变量"></a>在底部添加 PATH 变量</h3><p>   export PATH=$PATH:/usr/local/node/bin</p><h3 id="保存退出，先按esc键，再按shift-："><a href="#保存退出，先按esc键，再按shift-：" class="headerlink" title="保存退出，先按esc键，再按shift+："></a>保存退出，先按esc键，再按shift+：</h3><p>   wq</p><h3 id="最后保存并使其生效即可"><a href="#最后保存并使其生效即可" class="headerlink" title="最后保存并使其生效即可"></a>最后保存并使其生效即可</h3><p>   source /etc/profile</p><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h2>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我直接安装在/usr/local，你们可以自己选择安装目录</span><br><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line">#  创建目录</span><br><span class="line">mkdir hexo</span><br><span class="line"></span><br><span class="line">#  切换目录</span><br><span class="line">cd hexo</span><br><span class="line"></span><br><span class="line">#  安装Git(已安装可跳过)</span><br><span class="line">yum install git-core</span><br><span class="line"></span><br><span class="line">#  安装 Hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">#  初始化 Hexo</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>   2.安装插件</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这是一般主题所需的插件，只是建议安装！</span><br><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-stylus --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><p>   3.新建标签tags页面</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下：</span><br><span class="line">cd /usr/local/hexo</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容：</span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2019-10-26 19:46:20</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>   4.新建分类categories页面</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下：</span><br><span class="line">cd /usr/local/hexo</span><br><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：</span><br><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-10-26 19:46:03</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="3-测试Hexo是否搭建成功"><a href="#3-测试Hexo是否搭建成功" class="headerlink" title="3.测试Hexo是否搭建成功"></a>3.测试Hexo是否搭建成功</h2>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hexo</span><br><span class="line"></span><br><span class="line">hexo s   （启动hexo ）</span><br><span class="line">然后在浏览器访问，默认端口是4000</span><br><span class="line">(如果写发表文章,可以把你的.md 文件放在/usr/local/hexo/source/_posts，然后再启动，就可以在页面上看到你想发布的文章)</span><br></pre></td></tr></table></figure><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C123.png" alt="123"></p><h2 id="4-部署到GitHub"><a href="#4-部署到GitHub" class="headerlink" title="4.部署到GitHub"></a>4.部署到GitHub</h2><p>   1.注册你的github</p><p>   2.在github上添加一个新的ssh密钥</p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C1234.png" alt="1234"></p><p>   3.获取主机（linux）上的密钥</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@centos9 ~]]# ssh-keygen </span><br><span class="line">[root@centos9 ~]# cat  ~/.ssh/id_rsa.pub </span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZwJCv9CwzElYpRZ2ZypMzN5rk0sCFtdVmZrosVp84EiYGJVlTGOmSz7ez9oS4C7d1xHbJwQPhTCT0UPxgnuw/I4Hix91tzw6wWjbr0ahxeEs0A6/cyBH1J6AWTgXn1g2Z6tW1PaYo/Bu4cFKPoLQhHJ/vsBQ5Y++MQJkxQJKO7ULvSnrBnkQDOi0u/zDevsZj1JSdZJ8mfjReBtwriZJyuYQKVUUS0mdxii8bnGbcGlifWJqjXwaD4+IZnHACSV62LcPfYq7V+XNcFzYyaiOSh8SoXn3QcmId3V7g7udcGXSYWm4Wh7h/KIqktbhCbs9h8w02w1UAX001+oO9uLG7 root@centos9</span><br></pre></td></tr></table></figure><p>   4.把你的公钥拷贝到GitHub上面</p><p>   5.创建博客项目</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建一个新项目，项目名称为 用户名.github.io ，比如我的Github用户名是Senzi-4588，则创建的项目名为</span><br><span class="line">Senzi-4588.github.io</span><br><span class="line">(注意：用户名是你的github用户名哦！千万别弄错了，不然访问不到</span><br><span class="line">的！)</span><br></pre></td></tr></table></figure><p>   6.配置Hexo，编译与部署与测试</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/hexo</span><br><span class="line"></span><br><span class="line">vim _config.yml</span><br><span class="line"></span><br><span class="line">#直接输入G,跳到文本末尾，找到如下配置信息:</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Senzi-4588/Senzi-4588.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH/mm/ss&quot;)&#125;&#125;&apos;</span><br><span class="line">  #这里，repo就是你创建的博客项目</span><br><span class="line"></span><br><span class="line">  #最后一步，编译，上传静态代码</span><br><span class="line">  # 编译</span><br><span class="line">  hexo generate //可以简写 hexo g</span><br><span class="line">  </span><br><span class="line">  # 在主机的hexo目录下 执行以下命令将自动更新到Github</span><br><span class="line">  hexo d //可以简写 hexo d</span><br></pre></td></tr></table></figure><p>   7.报错信息</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果 hexo d 报错  ERROR Deployer not found:</span><br><span class="line">npm install --save hexo-deployer-git</span><br><span class="line"></span><br><span class="line">其他命令：</span><br><span class="line">hexo clean //清空你hexo/public里的内容，可以在每次修改配置文件后清除一下</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d //多条命令可以一块输入</span><br><span class="line"></span><br><span class="line">这时候就配好了，你可以用你的项目名访问你博客网站了，如：http://Senzi-4588.github.io</span><br></pre></td></tr></table></figure><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C12345.png" alt="12345"></p><h2 id="5-阿里云域名解析"><a href="#5-阿里云域名解析" class="headerlink" title="5.阿里云域名解析"></a>5.阿里云域名解析</h2>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需求</span><br><span class="line">  因为Hexo个人博客是托管在github之上，每次访问都要使用githubname.github.io这么一个长串的域名来访问，会显得非常繁琐。这个时候我们可以购买一个域名，设置DNS跳转，以达到通过域名即可访问我们的个人博客。通过查阅文档发现，github pages是支持域名绑定的。</span><br><span class="line">购买域名</span><br><span class="line">  国内国外有很多的域名供应商，选择一个好的机构购买域名，会为自己的站点配置节约很多时间，也不会因为域名的出错，导致影响百度对我们个人博客的收录。近几年来，国内做的比较好的域名供应商有阿里的万网。我就是在阿里的万网购买的域名。通过查找，找到自己喜欢的域名，后来为了解决成本，我选了.top结尾的域名，一年只需要1块钱，很便宜，建议如果只是作为自己的博客使用建议不要购买.com的域名。(注意：购买.top域名之后，大概6个小时之内就会生效，5之内必须对域名进行认证，超过5天没有认证域名将会被锁定。)</span><br></pre></td></tr></table></figure><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C123456.png" alt="123456"></p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C1234567.png" alt="1234567"></p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C12345678.png" alt="12345678"></p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C123456789.png" alt="123456789"></p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C11111.png" alt="11111"></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击添加解析，记录类型选A或CNAME，A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是senzi-4588.github.io。</span><br></pre></td></tr></table></figure><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C1111111.png" alt="1111111"></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这些全部设置完成后，此时你并不能要申请的域名访问你的博客。接着你需要做的是在hexo根目录的source文件夹里创建CNAME文件，不带任何后缀，里面添加你的域名信息，如：senzi.top。</span><br><span class="line"></span><br><span class="line">实践证明如果此时你填写的是www.senzi.top那么以后你只能用www.senzi.top访问，而如果你填写的是senzi.top。那么用www.senzi.top和senzi.top访问都是可以的。重新清理hexo,并发布即可用新的域名访问。即hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>   最终测试：</p><p>   #<img src="C:%5CUsers%5CAdministrator%5CDesktop%5C121212.png" alt="121212"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Http</title>
      <link href="/2019/10/31/http/"/>
      <url>/2019/10/31/http/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表:"></a><strong>HTTP状态码列表:</strong></h1><table><thead><tr><th>状态码</th><th>状态码英文名称</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>继续。客户端应继续其请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td></td><td></td><td></td></tr><tr><td>200</td><td>OK</td><td>请求成功。一般用于GET与POST请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr><tr><td></td><td></td><td></td></tr><tr><td>300</td><td>Multiple Choices</td><td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td></td><td></td><td></td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解</td></tr><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>客户端请求中的方法被禁止</td></tr><tr><td>406</td><td>Not Acceptable</td><td>服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td>407</td><td>Proxy Authentication Required</td><td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td>408</td><td>Request Time-out</td><td>服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td>409</td><td>Conflict</td><td>服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td>410</td><td>Gone</td><td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td>411</td><td>Length Required</td><td>服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td>412</td><td>Precondition Failed</td><td>客户端请求信息的先决条件错误</td></tr><tr><td>413</td><td>Request Entity Too Large</td><td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td>414</td><td>Request-URI Too Large</td><td>请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td>415</td><td>Unsupported Media Type</td><td>服务器无法处理请求附带的媒体格式</td></tr><tr><td>416</td><td>Requested range not satisfiable</td><td>客户端请求的范围无效</td></tr><tr><td>417</td><td>Expectation Failed</td><td>服务器无法满足Expect的请求头信息</td></tr><tr><td></td><td></td><td></td></tr><tr><td>500</td><td>Internal Server Error</td><td>服务器内部错误，无法完成请求</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RAID</title>
      <link href="/2019/10/31/raid/"/>
      <url>/2019/10/31/raid/</url>
      
        <content type="html"><![CDATA[<h3 id="磁盘阵列RAID"><a href="#磁盘阵列RAID" class="headerlink" title="磁盘阵列RAID"></a>磁盘阵列RAID</h3><p>RAID：磁盘冗余阵列（Redundant Array of Independent Disks）<br>作 用：容错、提升读写速率</p><p>优点：</p><p>1、提高传输速率：raid通过在多个磁盘上同时存储和读取数据来大幅度提高存储系统的数据吞吐量。</p><p>2、通过数据校验提供容错功能：在很多raid模式中有都有较为完备的相互校验、恢复的措施，大大提高了raid系统的容错度，提高了系统稳定的冗余性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RAID类型                     个数                利用率           优缺点</span><br><span class="line">－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</span><br><span class="line">RAID0   条带集             2＋             100%            读写速率最快，不容错</span><br><span class="line">RAID1   镜像集                2   50%            读写速率一般，容错</span><br><span class="line">RAID5   带奇偶校验条带集   3＋             (n-1）/n        读写速率快，容错，允许坏一块</span><br><span class="line">RAID6   带奇偶校验条带集双校验dp 4＋             (n-2）/n      读写快，容错，允许坏两块</span><br><span class="line">RAID10 RAID1的安全＋RAID0的高速 450%读写速率快，容错</span><br><span class="line">－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－</span><br></pre></td></tr></table></figure><p>RAID 0（条带集）</p><p>最早的raid模式，两块以上的磁盘，实现的成本最低，读写速率最快，可以提高整个磁盘的性能和吞吐量。但是没有提供冗余或错误修复的能力，如果出现故障，无法进行任何补救，只有在对数据安全性不高的情况下才会使用。</p><p>把连续的数据依次分散写入各块盘中，整倍提高磁盘容量</p><p><img src="https://i.loli.net/2019/07/29/5d3e63da18de144158.png" alt=""></p><p>RAID 1(镜像集)</p><p>通过二次读写实现磁盘镜像，在数据写入一块磁盘时，同时会在另一块磁盘上生成镜像文件（把一个磁盘上的数据镜像到另一个磁盘上），有很好的磁盘冗余性，但成本高，磁盘利用率只有50%，不断地读写，对磁盘控制器的负载很大。</p><p><img src="https://i.loli.net/2019/07/29/5d3e63ea4fb6759224.png" alt=""></p><p>RAID 5（奇偶条带校验集）</p><p>是一种兼顾存储性能、数据安全、存储成本的存储方案，奇偶校验码存在于所有磁盘上，三块以上的磁盘，读取数据的速度很快，但写入一般，当一块磁盘数据损坏，利用剩下的数据和相对应的奇偶校验信息去恢复被损坏的数据。（允许怀掉一块盘）</p><p><img src="https://i.loli.net/2019/07/29/5d3e64001b3cd77708.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A值B值Xor结果</span><br><span class="line">000</span><br><span class="line">101</span><br><span class="line">011</span><br><span class="line">110</span><br></pre></td></tr></table></figure><p>RAID 6（奇偶条带校验集双校验）</p><p>是RAID5的扩展，将校验码写入两个驱动器中，增强磁盘容错能力，用于数据绝对不能出错的场合，需要四块以上的磁盘，对控制器的设计年的十分复杂，写入速度一般，用于计算奇偶校验值和验证数据的正确性所花费的时间多，会造成不必要的负载，一般只有军队用的得起。（允许坏掉两块盘）</p><p><img src="https://i.loli.net/2019/07/29/5d3e640db819992855.png" alt=""></p><p>RAID 10</p><p>raid0+1，raid0的高速+raid1的安全，除了数据可以依次导入磁盘，其每个盘都有自己的物理镜像盘，提供全冗余能力，读写速度快，但成本高，至少需要四个磁盘，磁盘利用率50%。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">一、不同场景RAID的使用</span><br><span class="line">RAID 实现方式</span><br><span class="line">硬RAID： 需要RAID卡，有自己的CPU，处理速度快，有电池和无电池</span><br><span class="line">软RAID： 通过操作系统实现，比如Windows、Linux</span><br><span class="line"></span><br><span class="line">二、RAID5 (3块硬盘) + 热备(1块硬盘)</span><br><span class="line">1. 准备4块硬盘</span><br><span class="line">[root@tianyun ~]# ll /dev/sd*</span><br><span class="line">brw-rw---- 1 root disk 8,  48 Jan 13 16:07 /dev/sdd</span><br><span class="line">brw-rw---- 1 root disk 8,  64 Jan 13 16:07 /dev/sde</span><br><span class="line">brw-rw---- 1 root disk 8,  80 Jan 13 16:07 /dev/sdf</span><br><span class="line">brw-rw---- 1 root disk 8,  80 Jan 13 16:07 /dev/sdg</span><br><span class="line">   </span><br><span class="line">2. 创建RAID</span><br><span class="line">[root@tianyun ~]# yum -y install mdadm      //确保mdadm命令可用</span><br><span class="line">[root@tianyun ~]# mdadm -C /dev/md0 -l5 -n3 -x1 /dev/sd&#123;d,e,f,g&#125;</span><br><span class="line">mdadm: array /dev/md0 started.</span><br><span class="line">-C创建RAID</span><br><span class="line">/dev/md0第一个RAID设备</span><br><span class="line">-l5 RAID5</span><br><span class="line">-n3RAID成员的数量</span><br><span class="line">-x1热备磁盘的数量</span><br><span class="line"></span><br><span class="line">3. 格式化，挂载</span><br><span class="line">[root@tianyun ~]# mkfs.xfs /dev/md0</span><br><span class="line">[root@tianyun ~]# mkdir /mnt/raid5</span><br><span class="line">[root@tianyun ~]# mount /dev/md0 /mnt/raid5</span><br><span class="line">[root@tianyun ~]# cp -rf /etc /mnt/raid5/etc1</span><br><span class="line"></span><br><span class="line">4. 查看RAID信息</span><br><span class="line">[root@tianyun ~]# mdadm -D /dev/md0     //-D 查看详细信息</span><br><span class="line">/dev/md0:</span><br><span class="line">        Version : 1.2</span><br><span class="line">  Creation Time : Mon Jan 13 16:28:47 2014</span><br><span class="line">     Raid Level : raid5</span><br><span class="line">     Array Size : 2095104 (2046.34 MiB 2145.39 MB)</span><br><span class="line">  Used Dev Size : 1047552 (1023.17 MiB 1072.69 MB)</span><br><span class="line">   Raid Devices : 3</span><br><span class="line">  Total Devices : 4</span><br><span class="line">    Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">    Update Time : Mon Jan 13 16:34:51 2014</span><br><span class="line">          State : clean </span><br><span class="line"> Active Devices : 3</span><br><span class="line">Working Devices : 4</span><br><span class="line"> Failed Devices : 0</span><br><span class="line">  Spare Devices : 1</span><br><span class="line"></span><br><span class="line">         Layout : left-symmetric</span><br><span class="line">     Chunk Size : 512K</span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       48        0      active sync   /dev/sdd</span><br><span class="line">       1       8       64        1      active sync   /dev/sde</span><br><span class="line">       4       8       80        2      active sync   /dev/sdf</span><br><span class="line"></span><br><span class="line">       3       8       96        -      spare   /dev/sdg</span><br><span class="line"></span><br><span class="line">5. 模拟一块硬盘损坏，并移除</span><br><span class="line">终端一：</span><br><span class="line">[root@tianyun ~]# watch -n 0.5 &apos;mdadm -D /dev/md0 | tail&apos;  //watch持续查看</span><br><span class="line">终端二：</span><br><span class="line">[root@tianyun ~]# mdadm /dev/md0 -f /dev/sde -r /dev/sde  </span><br><span class="line">//模拟坏了并移除  -f  --fail  -r  --remove</span><br><span class="line"></span><br><span class="line">6. 设置RAID开机生效</span><br><span class="line">[root@tianyun ~]# mdadm -D -s</span><br><span class="line">ARRAY /dev/md0 metadata=1.2 name=sxl1.com:0 UUID=c6761621:8878498f:f5be209e</span><br><span class="line">[root@tianyun ~]# mdadm -D -s &gt; /etc/mdadm.conf</span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line">mdadm选项：</span><br><span class="line">-s  --scan</span><br><span class="line">-S  --stop</span><br><span class="line">-D  --detail</span><br><span class="line">-C  --create</span><br><span class="line">-f   --fail</span><br><span class="line">-r   --remove</span><br><span class="line">-n  --raid-devices=3</span><br><span class="line">-x  --spare-devices=1</span><br><span class="line">-l   --level=5</span><br><span class="line"></span><br><span class="line">========================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">    Update Time : Mon Aug  4 22:47:47 2014</span><br><span class="line">          State : clean, degraded, recovering</span><br><span class="line"> Active Devices : 2</span><br><span class="line">Working Devices : 3</span><br><span class="line"> Failed Devices : 0</span><br><span class="line">  Spare Devices : 1</span><br><span class="line"></span><br><span class="line">         Layout : left-symmetric</span><br><span class="line">     Chunk Size : 512K</span><br><span class="line"></span><br><span class="line"> Rebuild Status : 3% complete</span><br><span class="line"></span><br><span class="line">           Name : localhost.localdomain:0  (local to host localhost.localdomain)</span><br><span class="line">           UUID : 3df9624c:138a5b3e:2f557132:59a43d04</span><br><span class="line">         Events : 41</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Rsync</title>
      <link href="/2019/10/31/rsync/"/>
      <url>/2019/10/31/rsync/</url>
      
        <content type="html"><![CDATA[<p>环境<br>操作系统：CentOS 7u3<br>源服务器：192.168.179.128<br>目标服务器：192.168.179.129<br>目的：把目标服务器上/home_test目录实时同步到源服务器的/home_test下<br>注意：配置相关端⼝和安全规则。源服务器去同步目标服务器上的内容</p><h2 id="192-168-179-128-源服务器"><a href="#192-168-179-128-源服务器" class="headerlink" title="192.168.179.128(源服务器)"></a>192.168.179.128(源服务器)</h2><h3 id="一、-安装rsync"><a href="#一、-安装rsync" class="headerlink" title="一、 安装rsync"></a>一、 安装rsync</h3><p>rhel7:<br>yum install rsync<br>systemctl start rsyncd<br>rhel6:<br>yum install rsync xinetd<br>vi /etc/xinetd.d/rsync<br>disable = no<br>/etc/init.d/xinetd start<br>注意：6里面rsync依据超级守护进程启动</p><h3 id="二、创建rsyncd-conf配置文件"><a href="#二、创建rsyncd-conf配置文件" class="headerlink" title="二、创建rsyncd.conf配置文件"></a>二、创建rsyncd.conf配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">pidfile = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsync.lock</span><br><span class="line">secrets file = /etc/rsync.pass</span><br><span class="line">motd file = /etc/rsyncd.Motd</span><br><span class="line">[home_test]</span><br><span class="line">path = /home_test</span><br><span class="line">comment = home_test</span><br><span class="line">uid = root</span><br><span class="line">gid = root</span><br><span class="line">port = 873</span><br><span class="line">use chroot = no</span><br><span class="line">read only = no</span><br><span class="line">list = no</span><br><span class="line">max connections = 200</span><br><span class="line">timeout = 600</span><br><span class="line">auth users = user1</span><br><span class="line">hosts allow = 192.168.75.152</span><br><span class="line">hosts deny = 192.168.245.150</span><br></pre></td></tr></table></figure><p>vim /etc/rsyncd.conf #7上有默认配置文件，rhel6上没有默认文件要<br>自己创建配置文件，添加以下代码<br>log file = /var/log/rsyncd.log #遇到错误可以查看日志，很详细<br>pidfile = /var/run/rsyncd.pid<br>lock file = /var/run/rsync.lock<br>secrets file = /etc/rsync.pass #用户认证配置文件，里面保存用<br>户名称和密码，后面会创建这个文件<br>motd file = /etc/rsyncd.Motd #rsync启动时欢迎信息页面文件<br>位置<br>[home_test] #同步模块名称，自定义（不要太短了）<br>path = /home_test #rsync服务端数据目录路径<br>comment = home_test #模块名称，和[host_test]一样<br>uid = root 需要两服务器目录和文件的属主属组<br>gid = root 需要两服务器目录和文件的属主属组<br>port=873 rsync 默认端口<br>use chroot = no<br>read only = no<br>list = no #不显示rsync服务端资源列表<br>max connections = 200<br>timeout = 600<br>auth users = user1 #执行数据同步的用户名，可以设置多个，用<br>英文状态下逗号隔开<br>hosts allow = 192.168.245.147 #允许进⾏数据同步的客户端IP地<br>址，可以设置多个，用英文状态下逗号隔开<br>hosts deny = 192.168.245.150 不允许同步的ip地址，用逗号隔<br>开</p><h3 id="三、创建用户认证文件"><a href="#三、创建用户认证文件" class="headerlink" title="三、创建用户认证文件"></a>三、创建用户认证文件</h3><p>vim /etc/rsync.pass<br>user1:123456 #格式，用户名:密码，可以设置多个，每行一个用户名:密码</p><h3 id="四、设置文件权限"><a href="#四、设置文件权限" class="headerlink" title="四、设置文件权限"></a>四、设置文件权限</h3><p>chmod 600 /etc/rsyncd.conf #设置文件所有者读取、写入权限<br>chmod 600 /etc/rsync.pass #设置文件所有者读取、写入权限<br>systemctl restart rsyncd #重启rsync</p><h2 id="192-168-179-129（目标服务器）"><a href="#192-168-179-129（目标服务器）" class="headerlink" title="192.168.179.129（目标服务器）"></a>192.168.179.129（目标服务器）</h2><h3 id="一、安装rsync、xinetd"><a href="#一、安装rsync、xinetd" class="headerlink" title="一、安装rsync、xinetd"></a>一、安装rsync、xinetd</h3><p>yum - y install rsync xinetd</p><h3 id="二、创建密码文件"><a href="#二、创建密码文件" class="headerlink" title="二、创建密码文件"></a>二、创建密码文件</h3><p>vim /etc/passwd.txt<br>123456 #密码<br>注意：这里的密码和客户端的密码是一样的<br>chmod 600 /etc/passwd.txt #设置文件权限，只设置文件所有者具<br>有读取、写入权限</p><h3 id="三、测试同步"><a href="#三、测试同步" class="headerlink" title="三、测试同步"></a>三、测试同步</h3><p>创建好测试目录</p><p>mkdir /home_test(源服务器和目标服务器都要创建)</p><p>rsync -avH –port=873 –progress –delete /home_test <a href="mailto:user1@192.168.179.128" target="_blank" rel="noopener">user1@192.168.179.128</a>::home_test –password-file=/etc/passwd.txt</p><p>/home_test 是指服务端数据⽬录<br>user1 是客户端设置好的账号<br>home_test 是指客户端设置的模块名称<br>同步失败查看文后的错误解决方法</p><h3 id="四、安装Inotify-tools工具，实时触发rsync进行同步"><a href="#四、安装Inotify-tools工具，实时触发rsync进行同步" class="headerlink" title="四、安装Inotify-tools工具，实时触发rsync进行同步"></a>四、安装Inotify-tools工具，实时触发rsync进行同步</h3><p>1、查看服务器内核是否支持inotify （下面输出说明支持）<br>ll /proc/sys/fs/inotify<br>-rw-r–r– 1 root root 0 Mar 7 02:17 max_queued_events<br>-rw-r–r– 1 root root 0 Mar 7 02:17 max_user_instances<br>-rw-r–r– 1 root root 0 Mar 7 02:17 max_user_watches<br>2、安装inotify-tools<br>wget <a href="http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz" target="_blank" rel="noopener">http://github.com/downloads/rvoicilas/inotify-tools/inotify-tools-3.14.tar.gz</a><br>tar zxvf inotify-tools-3.14.tar.gz<br>cd inotify-tools-3.14<br>./configure –prefix=/usr/local/inotify &amp;&amp; make &amp;&amp; make<br>install</p><p>（ps:如果编译安装有错的话，下载依赖包</p><p>yum install -y <em>epel</em> gcc-c++ unixODBC unixODBC-devel openssl-devel ncurses-devel）</p><p>3、设置系统环境变量，添加软连接</p><p>echo “PATH=/usr/local/inotify/bin:$PATH” &gt;&gt;/etc/profile.d/inotify.sh<br>source /etc/profile.d/inotify.sh<br>echo “/usr/local/inotify/lib” &gt;/etc/ld.so.conf.d/inotify.conf<br>ln -s /usr/local/inotify/include /usr/include/inotify<br>ln -s /usr/local/inotify/lib/libnotifytools.so.0 /usr/lib64</p><p>4、修改inotify默认参数（inotify默认内核参数值太小）<br>查看系统默认参数值<br>sysctl -a | grep max_queued_events<br>结果是：fs.inotify.max_queued_events = 16384<br>sysctl -a | grep max_user_watches<br>结果是：fs.inotify.max_user_watches = 8192<br>sysctl -a | grep max_user_instances<br>结果是：fs.inotify.max_user_instances = 128</p><p>5、修改参数：<br>sysctl -w fs.inotify.max_queued_events=”99999999”<br>sysctl -w fs.inotify.max_user_watches=”99999999”<br>sysctl -w fs.inotify.max_user_instances=”65535”<br>或者 vim /etc/sysctl.conf #添加以下代码<br>fs.inotify.max_queued_events=99999999<br>fs.inotify.max_user_watches=99999999<br>fs.inotify.max_user_instances=65535<br>参数说明<br>max_queued_events：<br>inotify队列最大长度，如果值太小，会出现”** Event Queue<br>Overflow **”错误，导致监控文件不准确<br>max_user_watches：</p><p>要同步的文件包含多少目录，可以用：find /home_test -<br>type d | wc -l 统计，必须保证max_user_watches值大于统<br>计结果（这里/home_test为同步文件目录）<br>max_user_instances：<br>每个用户创建inotify实例最大值</p><p>6、创建脚本，实时触发rsync进文同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/inotify/rsync.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">srcdir=&quot;/home_test&quot;</span><br><span class="line">dstdir=&quot;home_test&quot;</span><br><span class="line">excludedir=&quot;/usr/local/inotify/exclude.list&quot;</span><br><span class="line">rsyncuser=&quot;user1&quot;</span><br><span class="line">rsyncpassdir=&quot;/etc/passwd.txt&quot;</span><br><span class="line">dstip=&quot;192.168.75.151&quot;</span><br><span class="line">for ip in $dstip</span><br><span class="line">do</span><br><span class="line">rsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdir</span><br><span class="line">done</span><br><span class="line">/usr/local/inotify/bin/inotifywait -mrq --timefmt &apos;%d/%m/%y %H:%M&apos; --format &apos;%T %w%f%e&apos; -e close_write,modify,delete,create,attrib,move $srcdir | while read file</span><br><span class="line">do</span><br><span class="line">for ip in $dstip</span><br><span class="line">do</span><br><span class="line">rsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdir</span><br><span class="line">echo &quot;$&#123;file&#125; was rsynced&quot; &gt;&gt; /tmp/rsync.log 2&gt;&amp;1</span><br><span class="line">done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>修改权限<br>chmod +x /usr/local/inotify/rsync.sh<br>脚本参数说明：<br>excludedir=/usr/local/inotify/exclude.list<br>不需要同步的目录，如果有多个，每一行写一个目录，使用相<br>对于同步模块的路径；</p><p>7、设置脚本开机自动执行<br>vim /etc/rc.d/rc.local #编辑，在最后添加一行<br>sh /usr/local/inotify/rsync.sh &amp; ＃设置开机开动在后台运行<br>脚本<br>chmod +x /etc/rc.d/rc.local<br>systemctl enable rc-local</p><p>inotify参数<br>-m 是保持一直监听<br>-r 是递归查看目录<br>-q 是打印出事件<br>-e create,move,delete,modify,attrib 是指 “监听 创建 移动 删除 写入 权限” 事件</p><p>rsync参数<br>-v, –verbose 详细模式输出<br>-q, –quiet 精简输出模式<br>-c, –checksum 打开校验开关，强制对文件传输进行校验<br>-a, –archive 归档模式，表示以递归方式传输文件，并保持<br>所有文件属性，等于-rlptgoD<br>-r, –recursive 对子目录以递归模式处理<br>-R, –relative 使用相对路径信息<br>-b, –backup 创建备份，也就是对于目的已经存在有同样的<br>文件名时，将老的文件重新命名为<del>filename。可以使用–<br>suffix选项来指定不同的备份文件前缀。<br>–backup-dir 将备份文件(如</del>filename)存放在在目录下。<br>-suffix=SUFFIX 定义备份文件前缀<br>-u, –update 仅仅进行更新，也就是跳过所有已经存在于<br>DST，并且文件时间晚于要备份的文件。(不覆盖更新的⽂件)<br>-l, –links 保留软链结<br>-L, –copy-links 想对待常规文件一样处理软链结<br>–copy-unsafe-links 仅仅拷备指向SRC路径目录树以外的链<br>结<br>–safe-links 忽略指向SRC路径目录树以外的链结<br>-H, –hard-links 保留硬链结<br>-p, –perms 保持文件权限<br>-o, –owner 保持文件属主信息<br>-g, –group 保持文件属组信息<br>-D, –devices 保持设备文件信息<br>-t, –times 保持文件时间信息<br>-S, –sparse 对稀疏文件进行特殊处理以节省DST的空间<br>-n, –dry-run现实哪些文件将被传输<br>-W, –whole-file 拷备文件，不进行增量检测<br>-x, –one-file-system 不要跨越文件系统边界<br>-B, –block-size=SIZE 检验算法使用的块尺寸，默认是700<br>字节<br>-e, –rsh=COMMAND 指定使用rsh、ssh方式进行数据同步<br>–rsync-path=PATH 指定远程服务器上的rsync命令所在路<br>径信息<br>-C, –cvs-exclude 使用和CVS一样的方法自动忽略文件，用<br>来排除那些不希望传输的文件<br>–existing 仅仅更新那些已经存在于DST的文件，而不备份<br>那些新创建的文件<br>–delete 删除那些DST中SRC没有的文件<br>–delete-excluded 同样删除接收端那些被该选项指定排除的<br>文件<br>–delete-after 传输结束以后再删除<br>–ignore-errors 及时出现IO错误也进行删除<br>–max-delete=NUM 最多删除NUM个文件<br>–partial 保留那些因故没有完全传输的文件，以是加快随后<br>的再次传输<br>–force 强制删除⽬录，即使不为空<br>–numeric-ids 不将数字的用户和组ID匹配为用户名和组名<br>–timeout=TIME IP超时时间，单位为秒<br>-I, –ignore-times 不跳过那些有同样的时间和长度的文件<br>–size-only 当决定是否要备份文件时，仅仅察看文件大小而<br>不考虑文件时间<br>–modify-window=NUM 决定文件是否时间相同时使用的时<br>间戳窗口，默认为0<br>-T –temp-dir=DIR 在DIR中创建临时文件<br>–compare-dest=DIR 同样比较DIR中的文件来决定是否需要<br>备份<br>-P 等同于 –partial<br>–progress 显示备份过程<br>-z, –compress 对备份的文件在传输时进行压缩处理<br>–exclude=PATTERN 指定排除不需要传输的文件模式<br>–include=PATTERN 指定不排除而需要传输的文件模式</p><h3 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h3><p>在目标文件/home_test下创建a.txt</p><p>cat a.txt</p><p>test123</p><p>执行脚本进行手动同步</p><p>sh /usr/local/inotify/rsync.sh</p><p>（ps：报错</p><p>rsync: failed to open exclude file /usr/local/inotify/exclude.list: No such file or directory (2)<br>rsync error: error in file IO (code 11) at exclude.c(1178) [client=3.1.2]<br>/usr/local/inotify/rsync.sh: line 12: /usr/local/inotify/bin/inotifywait: No such file or directory</p><p>mkdir -p /usr/local/inotify/exclude.list</p><p>mkdir -p /usr/local/inotify/bin/inotifywait</p><p>chmod a+x /usr/local/inotify/bin/inotifywait</p><p>）</p><p>在源服务器/hmoe_test下可以看见</p><p>cat a.txt</p><p>test123</p><h2 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h2><p>问题一：<br>@ERROR: chroot failed<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1522) [receiver=3.0.3]<br>原因：<br>服务器端的目录不存在或无权限，创建目录并修正权限可解决问题。</p><p>问题二：<br>@ERROR: auth failed on module tee<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1522) [receiver=3.0.3]<br>原因：<br>服务器端该模块（tee）需要验证用户名密码，但客户端没有提供正确的用户名密码，认证失败。<br>提供正确的用户名密码解决此问题。</p><p>问题三：<br>@ERROR: Unknown module ‘tee_nonexists’<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1522) [receiver=3.0.3]<br>原因：<br>服务器不存在指定模块。提供正确的模块名或在服务器端修改成你要<br>的模块以解决问题。</p><p>问题1：<br>在client上遇到问题：<br>rsync -auzv –progress –password-file=/etc/rsync.pas<br><a href="mailto:root@192.168.133.128" target="_blank" rel="noopener">root@192.168.133.128</a>::backup /home/<br>rsync: could not open password file “/etc/rsync.pas”: No such file or<br>directory (2)<br>Password:<br>@ERROR: auth failed on module backup<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1506) [Receiver=3.0.7]<br>遇到这个问题：client端没有设置/etc/rsync.pas这个文件，而在使用<br>rsync命令的时候，加了这个参数–<br>password-file=/etc/rsync.pas</p><p>问题2：<br>rsync -auzv –progress –password-file=/etc/rsync.pas<br><a href="mailto:root@192.168.133.128" target="_blank" rel="noopener">root@192.168.133.128</a>::backup /home/<br>@ERROR: auth failed on module backup<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1506) [Receiver=3.0.7]<br>遇到这个问题：client端已经设置/etc/rsync.pas这个文件，里面也设置<br>了密码111111，和服务器一致，但是<br>服务器段设置有错误，服务器端应该设置/etc/rsync.pas ，里面内容<br>root:111111 ,这里登陆名不可缺少</p><p>问题3：<br>rsync -auzv –progress –password-file=/etc/rsync.pas<br><a href="mailto:root@192.168.133.128" target="_blank" rel="noopener">root@192.168.133.128</a>::backup /home/<br>@ERROR: chdir failed<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1506) [Receiver=3.0.7]<br>遇到这个问题，是因为服务器端的/home/backup 其中backup这个目<br>录并没有设置，所以提示：chdir failed</p><p>问题4：<br>rsync: write failed on “/home/backup2010/wensong”: No space left<br>on device (28)<br>rsync error: error in file IO (code 11) at receiver.c(302)<br>[receiver=3.0.7]<br>rsync: connection unexpectedly closed (2721 bytes received so far)<br>[generator]<br>rsync error: error in rsync protocol data stream (code 12) at io.c(601)<br>[generator=3.0.7]<br>磁盘空间不够，所以无法操作。<br>可以通过df /home/backup2010 来查看可用空间和已用空间</p><p>问题5：网络收集问题<br>1、权限问题<br>类似如下的提示：rsync: opendir “/kexue” (in dtsChannel) failed:<br>Permission denied (13)注意查看同步的目录权限是否为755<br>2、time out<br>rsync: failed to connect to 203.100.192.66: Connection timed out<br>(110)<br>rsync error: error in socket IO (code 10) at clientserver.c(124)<br>[receiver=3.0.5]<br>检查服务器的端⼝netstat –tunlp，远程telnet测试。<br>可能因为客户端或者服务端的防火墙开启 导致⽆法通信，可以设置规<br>则放行 rsync（873端口） 或者直接关闭防火墙。<br>还有一种在同步过程中可能会提示没有权限 （将同步目录加上<br>SvcwRsync全部权限即可，更简单的方法就是将SvcwRsync设为管理<br>员即可）<br>3、服务未启动<br>rsync: failed to connect to 10.10.10.170: Connection refused (111)<br>rsync error: error in socket IO (code 10) at clientserver.c(124)<br>[receiver=3.0.5]<br>启动服务：rsync –daemon –config=/etc/rsyncd.conf<br>4、磁盘空间满<br>rsync: recv_generator: mkdir “/teacherclubBackup/rsync……” failed:<br>No space left on device (28)<br><strong>* Skipping any contents from this failed directory *</strong><br>5、Ctrl+C或者大量文件<br>rsync error: received SIGINT, SIGTERM, or SIGHUP (code 20) at<br>rsync.c(544) [receiver=3.0.5]<br>rsync error: received SIGINT, SIGTERM, or SIGHUP (code 20) at<br>rsync.c(544) [generator=3.0.5]<br>说明：导致此问题多半是服务端服务没有被正常启动，到服务器上去<br>查查服务是否有启动，然后查看下 /var/run/rsync.pid 文件是否存在，最干脆的方法是杀死已经启动了服务，然后再次启动服务或者让脚本加入系统启动服务级别然后shutdown -r now服务器<br>6、xnetid启动<br>rsync: read error: Connection reset by peer (104)<br>rsync error: error in rsync protocol data stream (code 12) at io.c(759)<br>[receiver=3.0.5]<br>查看rsync日志<br>rsync: unable to open configuration file “/etc/rsyncd.conf”: No such<br>file or directory<br>xnetid查找的配置文件位置默认是/etc下，根据具体情况创建软链接。<br>例如：<br>ln -s /etc/rsyncd/rsyncd.conf /etc/rsyncd.conf<br>或者更改指定默认的配置文件路径，在/etc/xinetd.d/rsync配置文件<br>中。<br>Rsync configure:<br>配置一：<br>ignore errors<br>说明：这个选项最好加上，否则再很多crontab的时候往往发生错误你也未可知，因为你不可能天天去看每时每刻去看log，不加上这个出现错误的几率相对会很高，因为任何大点的项目和系统，磁盘IO都是一个瓶颈<br>Rsync error：<br>错误一：<br>@ERROR: auth failed on module xxxxx<br>rsync: connection unexpectedly closed (90 bytes read so far)<br>rsync error: error in rsync protocol data stream (code 12) at io.c(150)<br>说明：这是因为密码设置错了，无法登入成功，检查一下rsync.pwd，看客服是否匹配。还有服务器端没启动rsync 服务也会出现这种情况。<br>错误二：<br>password file must not be other-accessible<br>continuing without password file<br>Password:<br>说明：这是因为rsyncd.pwd rsyncd.sec的权限不对，应该设置为<br>600。如：chmod 600 rsyncd.pwd</p><p>错误三：<br>@ERROR: chroot failed<br>rsync: connection unexpectedly closed (75 bytes read so far)<br>rsync error: error in rsync protocol data stream (code 12) at io.c(150)<br>说明：这是因为你在 rsync.conf 中设置的 path 路径不存在，要新建目录才能开启同步</p><p>错误四：<br>rsync: failed to connect to 218.107.243.2: No route to host (113)<br>rsync error: error in socket IO (code 10) at clientserver.c(104)<br>[receiver=2.6.9]<br>说明：防火墙问题导致，这个最好先彻底关闭防火墙，排错的基本法<br>就是这样，无论是S还是C，还有ignore errors选项问题也会导致</p><p>错误五：<br>@ERROR: access denied to www from unknown (192.168.1.123)<br>rsync: connection unexpectedly closed (0 bytes received so far)<br>[receiver]<br>rsync error: error in rsync protocol data stream (code 12) at io.c(359)<br>说明：此问题很明显，是配置选项host allow的问题，初学者喜欢一个允许段做成一个配置，然后模块又是同一个，致使导致</p><p>错误六：<br>rsync error: received SIGINT, SIGTERM, or SIGHUP (code 20) at<br>rsync.c(244) [generator=2.6.9]<br>rsync error: received SIGUSR1 (code 19) at main.c(1182)<br>[receiver=2.6.9]<br>说明：导致此问题多半是服务端服务没有被正常启动，到服务器上去<br>查查服务是否有启动，然后查看下 /var/run/rsync.pid 文件是否存在，最干脆的方法是杀死已经启动了服务，然后再次启动服务或者让脚本加入系统启动服务级别然后shutdown -r now服务器</p><p>错误七：<br>rsync: read error: Connection reset by peer (104)<br>rsync error: error in rsync protocol data stream (code 12) at io.c(604)<br>[sender=2.6.9]<br>说明：原数据目录里⾥没有数据存在<br>rsync 错误与解决⽅法整理补充篇<br>由于我们经常使用rsync进行服务器文件的同步工作，但在配置过程<br>中，会出现很多问题，下面的错误基本上都是通过客户端返回的错误<br>进行分析。<br>另外查找错误过程中也学到了一个查看错误的⽅法-查看系统日志，我们操作的每步都会在日志上有说明，有时候报错看不懂，日志上都写的清清楚楚。<br>命令：cat /var/log/messages</p><p>问题一：<br>@ERROR: auth failed on module bachup<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1522) [receiver=3.0.3]<br>原因：服务器端该模块（backup）需要验证⽤户名密码，但客户端没<br>有提供正确的用户名密码，认证失败。 提供正确的用户名密码解决此<br>问题。<br>这个问题比较蠢，如果可能你和我⼀样明明在模块里写了密码文件，<br>怎么都不通，这个时候我劝你先检查一下所写模块中是不是和下图一<br>样。比如，某处多了个s。</p><p>问题二：110错误 -time out<br>rsync: failed to connect to 203.100.192.66: Connection timed out<br>(110)<br>rsync error: error in socket IO (code 10) at clientserver.c(124)<br>[receiver=3.0.5]<br>原因：<br>检查服务器的端口netstat –tunlp，远程telnet测试。 可能因为客户端<br>或者服务端的防火墙开启 导致无法通信，可以设置规则放行rsync（873端口） 或者直接关闭防⽕墙。<br>在这里博主是重启过服务器，然后就报110了，直接开启rsync服务就<br>行。<br>命令：service rsyncd start<br>问题三：113错误 -防火墙<br>rsync: failed to connect to 218.107.243.2: No route to host (113) rsync<br>error: error in socket IO (code 10) at clientserver.c(104)<br>[receiver=2.6.9]<br>原因：<br>防火墙问题导致，这个很简单，关闭防火墙就可以。不过博主还是被<br>困在这里几个小时，因为linux防火墙分两种：<br>-iptable和-firewall<br>认识到这个问题首先查看系统的防火墙种类，查看防火墙状态即可<br>service iptable status<br>firewall-cmd –state<br>确定防火墙种类后再按对应方法将防火墙关闭即可。<br>问题四：1516错误<br>@ERROR: auth failed on module backup<br>rsync error: error starting client-server protocol (code 5) at<br>main.c(1516) [Receiver=3.0.9]<br>解决：这个问题错误差别很大，可查看系统日志查看错误，再搜索解<br>决方法。<br>注意：一般这种情况都建立在可以连通的基础。去服务端查看系统日<br>志，可以查看相关错误。<br>命令：cat /var/log/massages<br>cat /var/log/rsyncd.log</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2019/10/31/redis/"/>
      <url>/2019/10/31/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><img src="https://i.loli.net/2019/05/03/5ccc19cfabc71.jpg" alt=""></p><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">什么是redis</span><br><span class="line">REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</span><br><span class="line"></span><br><span class="line">Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</span><br><span class="line"></span><br><span class="line">它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</span><br><span class="line">redis的官网：redis.io</span><br><span class="line">注:域名后缀io属于国家域名，是british Indian Ocean territory，即英属印度洋领地</span><br><span class="line"></span><br><span class="line">1.Redis是一个key-value存储系统。</span><br><span class="line">和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</span><br><span class="line"></span><br><span class="line">2.在此基础上，redis支持各种不同方式的排序。</span><br><span class="line">与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 </span><br><span class="line">Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。</span><br><span class="line"></span><br><span class="line">3.Redis支持主从同步。</span><br><span class="line">数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。存盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redis 与其他 key - value 缓存产品有以下三个特点：</span><br><span class="line"></span><br><span class="line">- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</span><br><span class="line">- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</span><br><span class="line">- Redis支持数据的备份，即master-slave模式的数据备份。</span><br></pre></td></tr></table></figure><h3 id="redis优势"><a href="#redis优势" class="headerlink" title="redis优势"></a>redis优势</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</span><br><span class="line">- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</span><br><span class="line">- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</span><br><span class="line">- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</span><br></pre></td></tr></table></figure><h3 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">下载地址http://redis.io/download，下载最新稳定版本。</span><br><span class="line">$ wget http://download.redis.io/releases/redis-4.0.9.tar.gz</span><br><span class="line">$ tar xzf redis-4.0.9.tar.gz -C /usr/local</span><br><span class="line">$ cd redis-4.0.9</span><br><span class="line">$ yum install -y make gcc</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><h3 id="redis简单配置"><a href="#redis简单配置" class="headerlink" title="redis简单配置"></a>redis简单配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cp redis.conf redis.conf.bak</span><br><span class="line"># vim redis.conf     ---修改如下</span><br><span class="line">bind 127.0.0.1　　#只监听内网IP</span><br><span class="line">daemonize yes　　　　　#开启后台模式将on改为yes</span><br><span class="line">timeout 300　　　　　　#连接超时时间</span><br><span class="line">port 6379                      #端口号</span><br><span class="line">databases 0                 存储Session的Redis库编号 16</span><br><span class="line">dir ./　　#本地数据库存放目录该目录需要存在</span><br><span class="line">pidfile /var/run/redis_6379.pid　　#定义pid文件</span><br><span class="line">logfile /var/log/redis_6379.log　　#定义log文件</span><br><span class="line">#requirepass tiger     # 设置密码</span><br></pre></td></tr></table></figure><p> cat  /etc/sysctl.conf </p><p>vm.overcommit_memory = 1</p><p>sysctl -p</p><p>日志： /var/log/redis_6379.log</p><h3 id="配置redis为systemctl启动"><a href="#配置redis为systemctl启动" class="headerlink" title="配置redis为systemctl启动"></a>配置redis为systemctl启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># cd /lib/systemd/system</span><br><span class="line"># vim redis.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Redis</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/data/application/redis/src/redis-server /data/application/redis/redis.conf  --daemonize no</span><br><span class="line">ExecStop=/data/application/redis/src/redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">=====================</span><br><span class="line">参数详解:</span><br><span class="line">• [Unit] 表示这是基础信息 </span><br><span class="line">• Description 是描述</span><br><span class="line">• After 是在那个服务后面启动，一般是网络服务启动后启动</span><br><span class="line"></span><br><span class="line">• [Service] 表示这里是服务信息 </span><br><span class="line">• ExecStart 是启动服务的命令</span><br><span class="line">• ExecStop 是停止服务的指令</span><br><span class="line"></span><br><span class="line">• [Install] 表示这是是安装相关信息 </span><br><span class="line">• WantedBy 是以哪种方式启动：multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。</span><br></pre></td></tr></table></figure><h3 id="redis启动"><a href="#redis启动" class="headerlink" title="redis启动"></a>redis启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make完后 redis-4.0.9目录下会出现编译后的redis服务程序redis-server,还有用于测试的客户端程序redis-cli,两个程序位于安装目录 src 目录下：</span><br><span class="line"></span><br><span class="line">下面启动redis服务.</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/05/07/5cd186575317a.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-server</span><br><span class="line"></span><br><span class="line">注意这种方式启动redis 使用的是默认配置。也可以通过启动参数告诉redis使用指定配置文件使用下面命令启动。</span><br><span class="line"></span><br><span class="line">$ cd src</span><br><span class="line">$ ./redis-server ../redis.conf</span><br><span class="line">redis.conf 是一个默认的配置文件。我们可以根据需要使用自己的配置文件。</span><br></pre></td></tr></table></figure><h3 id="redis客户端测试"><a href="#redis客户端测试" class="headerlink" title="redis客户端测试"></a>redis客户端测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ src/redis-cli</span><br><span class="line">127.0.0.1:6379&gt; set 1901 GZ</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get 1901</span><br><span class="line">&quot;GZ&quot;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="redis配置"><a href="#redis配置" class="headerlink" title="redis配置"></a>redis配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">redis的配置默认位于redis安装目录下，文件名未redis.conf</span><br><span class="line"></span><br><span class="line">Redis CONFIG 命令格式如下：</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br><span class="line"></span><br><span class="line">也可以通过命令查看或设置相关配置</span><br><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过* 查看所有配置</span><br><span class="line">127.0.0.1:6379&gt; config get *</span><br><span class="line">  1) &quot;dbfilename&quot;</span><br><span class="line">  2) &quot;dump.rdb&quot;</span><br><span class="line">  3) &quot;requirepass&quot;</span><br><span class="line">  4) &quot;&quot;</span><br><span class="line">  5) &quot;masterauth&quot;</span><br><span class="line">  6) &quot;&quot;</span><br><span class="line">  7) &quot;cluster-announce-ip&quot;</span><br><span class="line">  8) &quot;&quot;</span><br><span class="line">  9) &quot;unixsocket&quot;</span><br><span class="line"> 10) &quot;&quot;</span><br><span class="line"> 11) &quot;logfile&quot;</span><br><span class="line"> 12) &quot;&quot;</span><br><span class="line"> 13) &quot;pidfile&quot;</span><br><span class="line"> 14) &quot;&quot;</span><br><span class="line"> 15) &quot;slave-announce-ip&quot;</span><br><span class="line"> 16) &quot;&quot;</span><br><span class="line"> 17) &quot;replica-announce-ip&quot;</span><br><span class="line"> 18) &quot;&quot;</span><br><span class="line"> 19) &quot;maxmemory&quot;</span><br><span class="line"> 20) &quot;0&quot;</span><br><span class="line"> 21) &quot;proto-max-bulk-len&quot;</span><br><span class="line"> 22) &quot;536870912&quot;</span><br><span class="line"> 23) &quot;client-query-buffer-limit&quot;</span><br><span class="line"> 24) &quot;1073741824&quot;</span><br><span class="line"> 25) &quot;maxmemory-samples&quot;</span><br><span class="line"> 26) &quot;5&quot;</span><br><span class="line"> 27) &quot;lfu-log-factor&quot;</span><br><span class="line"> 28) &quot;10&quot;</span><br><span class="line"> 29) &quot;lfu-decay-time&quot;</span><br><span class="line"> 30) &quot;1&quot;</span><br><span class="line"> 31) &quot;timeout&quot;</span><br><span class="line"> 32) &quot;0&quot;</span><br><span class="line"> 33) &quot;active-defrag-threshold-lower&quot;</span><br><span class="line"> 34) &quot;10&quot;</span><br><span class="line"> 35) &quot;active-defrag-threshold-upper&quot;</span><br><span class="line"> 36) &quot;100&quot;</span><br><span class="line"> 37) &quot;active-defrag-ignore-bytes&quot;</span><br><span class="line"> 38) &quot;104857600&quot;</span><br><span class="line"> 39) &quot;active-defrag-cycle-min&quot;</span><br><span class="line"> 40) &quot;5&quot;</span><br><span class="line"> 41) &quot;active-defrag-cycle-max&quot;</span><br><span class="line"> 42) &quot;75&quot;</span><br><span class="line"> 43) &quot;active-defrag-max-scan-fields&quot;</span><br><span class="line"> 44) &quot;1000&quot;</span><br><span class="line"> 45) &quot;auto-aof-rewrite-percentage&quot;</span><br><span class="line"> 46) &quot;100&quot;</span><br><span class="line"> 47) &quot;auto-aof-rewrite-min-size&quot;</span><br><span class="line"> 48) &quot;67108864&quot;</span><br><span class="line"> 49) &quot;hash-max-ziplist-entries&quot;</span><br><span class="line"> 50) &quot;512&quot;</span><br><span class="line"> 51) &quot;hash-max-ziplist-value&quot;</span><br><span class="line"> 52) &quot;64&quot;</span><br><span class="line"> 53) &quot;stream-node-max-bytes&quot;</span><br><span class="line"> 54) &quot;4096&quot;</span><br><span class="line"> 55) &quot;stream-node-max-entries&quot;</span><br><span class="line"> 56) &quot;100&quot;</span><br><span class="line"> 57) &quot;list-max-ziplist-size&quot;</span><br><span class="line"> 58) &quot;-2&quot;</span><br><span class="line"> 59) &quot;list-compress-depth&quot;</span><br><span class="line"> 60) &quot;0&quot;</span><br><span class="line"> 61) &quot;set-max-intset-entries&quot;</span><br><span class="line"> 62) &quot;512&quot;</span><br><span class="line"> 63) &quot;zset-max-ziplist-entries&quot;</span><br><span class="line"> 64) &quot;128&quot;</span><br><span class="line"> 65) &quot;zset-max-ziplist-value&quot;</span><br><span class="line"> 66) &quot;64&quot;</span><br><span class="line"> 67) &quot;hll-sparse-max-bytes&quot;</span><br><span class="line"> 68) &quot;3000&quot;</span><br><span class="line"> 69) &quot;lua-time-limit&quot;</span><br><span class="line"> 70) &quot;5000&quot;</span><br><span class="line"> 71) &quot;slowlog-log-slower-than&quot;</span><br><span class="line"> 72) &quot;10000&quot;</span><br><span class="line"> 73) &quot;latency-monitor-threshold&quot;</span><br><span class="line"> 74) &quot;0&quot;</span><br><span class="line"> 75) &quot;slowlog-max-len&quot;</span><br><span class="line"> 76) &quot;128&quot;</span><br><span class="line"> 77) &quot;port&quot;</span><br><span class="line"> 78) &quot;6379&quot;</span><br><span class="line"> 79) &quot;cluster-announce-port&quot;</span><br><span class="line"> 80) &quot;0&quot;</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><p>编辑配置</p><p>可以通过修改redis.conf文件或者使用 CONFIG setm命令修改配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONFIG set 语法如下</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></figure><p>相关配置参数详解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> Redis配置文件参数说明:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span><br><span class="line"></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line">2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span><br><span class="line"></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line">3. 指定Redis监听端口，默认端口为6379，作者在自己的一篇博文中解释了为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</span><br><span class="line"></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">4. 绑定的主机地址</span><br><span class="line"></span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line">5.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</span><br><span class="line"></span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line">6. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</span><br><span class="line"></span><br><span class="line">loglevel verbose</span><br><span class="line"></span><br><span class="line">7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</span><br><span class="line"></span><br><span class="line">logfile stdout</span><br><span class="line"></span><br><span class="line">8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</span><br><span class="line"></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line">9. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line">Redis默认配置文件中提供了三个条件：</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line"></span><br><span class="line">save 300 10</span><br><span class="line"></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line">分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</span><br><span class="line"></span><br><span class="line">10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</span><br><span class="line"></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">11. 指定本地数据库文件名，默认值为dump.rdb</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">12. 指定本地数据库存放目录</span><br><span class="line"></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</span><br><span class="line"></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line">14. 当master服务设置了密码保护时，slav服务连接master的密码</span><br><span class="line"></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line">15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line"></span><br><span class="line">requirepass foobared</span><br><span class="line"></span><br><span class="line">16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</span><br><span class="line"></span><br><span class="line">maxclients 128</span><br><span class="line"></span><br><span class="line">17. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</span><br><span class="line"></span><br><span class="line">maxmemory &lt;bytes&gt;</span><br><span class="line"></span><br><span class="line">18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line">19. 指定更新日志文件名，默认为appendonly.aof</span><br><span class="line"></span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line">20. 指定更新日志条件，共有3个可选值：</span><br><span class="line"></span><br><span class="line">no：表示等操作系统进行数据缓存同步到磁盘（快）</span><br><span class="line"></span><br><span class="line">always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</span><br><span class="line"></span><br><span class="line">everysec：表示每秒同步一次（折衷，默认值）</span><br><span class="line"></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line">21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</span><br><span class="line"></span><br><span class="line">vm-enabled no</span><br><span class="line"></span><br><span class="line">22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</span><br><span class="line"></span><br><span class="line">vm-swap-file /tmp/redis.swap</span><br><span class="line"></span><br><span class="line">23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</span><br><span class="line"></span><br><span class="line">vm-max-memory 0</span><br><span class="line"></span><br><span class="line">24. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</span><br><span class="line"></span><br><span class="line">vm-page-size 32</span><br><span class="line"></span><br><span class="line">25. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</span><br><span class="line"></span><br><span class="line">vm-pages 134217728</span><br><span class="line"></span><br><span class="line">26. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</span><br><span class="line"></span><br><span class="line">vm-max-threads 4</span><br><span class="line"></span><br><span class="line">27. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</span><br><span class="line"></span><br><span class="line">glueoutputbuf yes</span><br><span class="line"></span><br><span class="line">28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</span><br><span class="line"></span><br><span class="line">hash-max-zipmap-entries 64</span><br><span class="line"></span><br><span class="line">hash-max-zipmap-value 512</span><br><span class="line"></span><br><span class="line">29. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</span><br><span class="line"></span><br><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure><h3 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</span><br></pre></td></tr></table></figure><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</span><br><span class="line"></span><br><span class="line">string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</span><br><span class="line"></span><br><span class="line">string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set name tigerfive</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;tigerfive&quot;</span><br><span class="line"></span><br><span class="line">我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 tigerfive</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Redis hash 是一个键值(key=&gt;value)对集合。</span><br><span class="line"></span><br><span class="line">Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash name tiger name2 five</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget myhash name</span><br><span class="line">&quot;tiger&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget myhash name2</span><br><span class="line">&quot;five&quot;</span><br><span class="line"></span><br><span class="line">实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</span><br><span class="line"></span><br><span class="line">每个 hash 可以存储 232 -1 键值对（40多亿）。</span><br></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist redis1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist redis2 redis3 redis4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lpush mylist tiger 1901</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 3</span><br><span class="line">1) &quot;1901&quot;</span><br><span class="line">2) &quot;tiger&quot;</span><br><span class="line">3) &quot;redis4&quot;</span><br><span class="line">4) &quot;redis3&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 10</span><br><span class="line">1) &quot;1901&quot;</span><br><span class="line">2) &quot;tiger&quot;</span><br><span class="line">3) &quot;redis4&quot;</span><br><span class="line">4) &quot;redis3&quot;</span><br><span class="line">5) &quot;redis2&quot;</span><br><span class="line">6) &quot;redis1&quot;</span><br><span class="line"></span><br><span class="line">上述示例我们通过 lpush 创建list并添加数据，通过lrange获取列表中的数据</span><br><span class="line">列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Redis的Set是string类型的无序集合。</span><br><span class="line"></span><br><span class="line">集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</span><br><span class="line"></span><br><span class="line">sadd 命令</span><br><span class="line">添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">127.0.0.1:6379&gt; sadd myset GZ BJ ZZ BK</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd myset TJ</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset TJ</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) &quot;BJ&quot;</span><br><span class="line">2) &quot;BK&quot;</span><br><span class="line">3) &quot;TJ&quot;</span><br><span class="line">4) &quot;GZ&quot;</span><br><span class="line">5) &quot;ZZ&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd myset SZ</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers myset </span><br><span class="line">1) &quot;BJ&quot;</span><br><span class="line">2) &quot;BK&quot;</span><br><span class="line">3) &quot;TJ&quot;</span><br><span class="line">4) &quot;GZ&quot;</span><br><span class="line">5) &quot;ZZ&quot;</span><br><span class="line">6) &quot;SZ&quot;</span><br><span class="line"></span><br><span class="line">注意：以上实例中 TJ 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</span><br><span class="line"></span><br><span class="line">集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</span><br></pre></td></tr></table></figure><h4 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</span><br><span class="line">不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</span><br><span class="line"></span><br><span class="line">zset的成员是唯一的,但分数(score)却可以重复。</span><br><span class="line"></span><br><span class="line">zadd 命令</span><br><span class="line">添加元素到集合，元素在集合中存在则更新对应score</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 0 GZ</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 0 BJ</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 0 ZZ</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myzset 0 5</span><br><span class="line">1) &quot;BJ&quot;</span><br><span class="line">2) &quot;GZ&quot;</span><br><span class="line">3) &quot;ZZ&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</span><br><span class="line"></span><br><span class="line">Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。</span><br><span class="line"></span><br><span class="line">每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[1]&gt; get myzset</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[1]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;tigerfive&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myzset 0 2</span><br><span class="line">1) &quot;BJ&quot;</span><br><span class="line">2) &quot;GZ&quot;</span><br><span class="line">3) &quot;ZZ&quot;</span><br><span class="line"></span><br><span class="line">然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内在只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。</span><br></pre></td></tr></table></figure><h3 id="redis命令"><a href="#redis命令" class="headerlink" title="redis命令"></a>redis命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Redis 命令用于在 redis 服务上执行操作。</span><br><span class="line"></span><br><span class="line">要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">Redis 客户端的基本语法为：</span><br><span class="line"></span><br><span class="line">$ redis-cli</span><br><span class="line"></span><br><span class="line">在远程服务上执行命令</span><br><span class="line">如果需要在远程 redis 服务上执行命令，同样我们使用的也是 redis-cli 命令。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><h3 id="redis数据备份和恢复"><a href="#redis数据备份和恢复" class="headerlink" title="redis数据备份和恢复"></a>redis数据备份和恢复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Redis SAVE 命令用于创建当前数据库的备份。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">redis Save 命令基本语法如下：</span><br><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">该命令会在redis安装目录下创建dump.rdb文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">恢复数据</span><br><span class="line">如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。获取 redis 目录可以使用 CONFIG 命令，如下所示：</span><br><span class="line">127.0.0.1:6379&gt; config get dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/redis/src&quot;</span><br><span class="line">以上命令 CONFIG GET dir 输出的 redis 安装目录为/usr/local/redis/src</span><br><span class="line"></span><br><span class="line">Bgsave</span><br><span class="line">创建 redis 备份文件也可以使用命令 BGSAVE，该命令在后台执行。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure><h3 id="redis安全"><a href="#redis安全" class="headerlink" title="redis安全"></a>redis安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">我们可以通过 redis 的配置文件设置密码参数，这样客户端连接到 redis 服务就需要密码验证，这样可以让你的 redis 服务更安全。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">默认情况下 requirepass 参数是空的，这就意味着你无需通过密码验证就可以连接到 redis 服务。</span><br><span class="line">你可以通过以下命令来修改该参数：</span><br><span class="line">127.0.0.1:6379&gt; CONFIG set requirepass &quot;tiger&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;tiger&quot;</span><br><span class="line"></span><br><span class="line">登录 </span><br><span class="line"></span><br><span class="line">或者登陆后认证</span><br><span class="line">127.0.0.1:6379&gt; AUTH &quot;tiger&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SET name &quot;Test value&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; GET name</span><br><span class="line">&quot;Test value&quot;</span><br></pre></td></tr></table></figure><h3 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">redis持久化 – 两种方式</span><br><span class="line">开启持久化功能后，重启redis后，数据会自动通过持久化文件恢复！！</span><br><span class="line"></span><br><span class="line">redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</span><br><span class="line"></span><br><span class="line">RDB，是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</span><br><span class="line"></span><br><span class="line">AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</span><br><span class="line"></span><br><span class="line">RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</span><br><span class="line"></span><br><span class="line">如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</span><br><span class="line"></span><br><span class="line">redis持久化 – RDB</span><br><span class="line">RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</span><br><span class="line"></span><br><span class="line">redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</span><br><span class="line"></span><br><span class="line">                -------------&gt;----------&gt;------------------&gt;</span><br><span class="line">                1 2 3 4 5  6 7 8 9  10 11 12 13  14 15 16</span><br><span class="line">                              -----------&gt;                   --------&gt;</span><br><span class="line">                              1 2 3 4 5                  1 2 3 4 5  6 7 8 9  10 11 12 13</span><br><span class="line"></span><br><span class="line">对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</span><br><span class="line"></span><br><span class="line">如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</span><br><span class="line"></span><br><span class="line">虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</span><br><span class="line"></span><br><span class="line">redis持久化 – AOF</span><br><span class="line">AOF，英文是Append Only File，即只允许追加不允许改写的文件。</span><br><span class="line">AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</span><br><span class="line"></span><br><span class="line">通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</span><br><span class="line"></span><br><span class="line">默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</span><br><span class="line"></span><br><span class="line">如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</span><br><span class="line"></span><br><span class="line">因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</span><br><span class="line"></span><br><span class="line">在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点可以放心。</span><br><span class="line"></span><br><span class="line">AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</span><br><span class="line"></span><br><span class="line">虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</span><br><span class="line"></span><br><span class="line">1 2 3 4 5 6     6zi</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</span><br><span class="line"></span><br><span class="line">如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</span><br><span class="line"></span><br><span class="line">1.备份被写坏的AOF文件</span><br><span class="line">2.运行redis-check-aof –fix进行修复</span><br><span class="line">3.用diff -u来看下两个文件的差异，确认问题点</span><br><span class="line">4.重启redis，加载修复后的AOF文件</span><br><span class="line"></span><br><span class="line">redis持久化 – AOF重写</span><br><span class="line"></span><br><span class="line">AOF重写的内部运行原理，有必要了解一下。</span><br><span class="line"></span><br><span class="line">在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</span><br><span class="line"></span><br><span class="line">与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</span><br><span class="line"></span><br><span class="line">当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</span><br><span class="line"></span><br><span class="line">当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</span><br><span class="line"></span><br><span class="line">redis持久化 – 如何选择RDB和AOF</span><br><span class="line">对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。</span><br><span class="line">写入速度快 AOF</span><br><span class="line">写入速度慢 RDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis的事务处理</span><br><span class="line">众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</span><br><span class="line"></span><br><span class="line">在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</span><br><span class="line"></span><br><span class="line">1.MULTI用来组装一个事务；</span><br><span class="line">2.EXEC用来执行一个事务；</span><br><span class="line">3.DISCARD用来取消一个事务；</span><br><span class="line">4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</span><br><span class="line"></span><br><span class="line">一个MULTI和EXEC的例子：</span><br><span class="line">redis&gt; MULTI //标记事务开始</span><br><span class="line">OK</span><br><span class="line">redis&gt; INCR user_id //多条命令按顺序入队</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; INCR user_id</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; PING</span><br><span class="line">QUEUED</span><br><span class="line">redis&gt; EXEC //执行</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 2</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) PONG</span><br><span class="line">在上面的例子中，看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</span><br><span class="line"></span><br><span class="line">对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</span><br><span class="line"></span><br><span class="line">有关事务，经常会遇到的是两类错误：</span><br><span class="line">1.调用EXEC之前的错误</span><br><span class="line">2.调用EXEC之后的错误</span><br><span class="line"></span><br><span class="line">“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; haha //一个明显错误的指令</span><br><span class="line">(error) ERR unknown command &apos;haha&apos;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec</span><br><span class="line">//redis无情的拒绝了事务的执行，原因是“之前出现了错误”</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">QUEUED</span><br><span class="line">//age不是集合，所以如下是一条明显错误的指令</span><br><span class="line">127.0.0.1:6379&gt; sadd age 15 </span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set age 29</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误</span><br><span class="line">1) OK</span><br><span class="line">2) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">&quot;29&quot; //可以看出第3条指令被成功执行了</span><br><span class="line">最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</span><br><span class="line"></span><br><span class="line">WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set age 23</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch age //开始监视age</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set age 25</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get age</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec //触发EXEC</span><br><span class="line">(nil) //事务无法被执行</span><br></pre></td></tr></table></figure><h2 id="redis主从-哨兵"><a href="#redis主从-哨兵" class="headerlink" title="redis主从  + 哨兵"></a>redis主从  + 哨兵</h2><h3 id="主从-用法"><a href="#主从-用法" class="headerlink" title="主从 - 用法"></a>主从 - 用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</span><br><span class="line">主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</span><br><span class="line">redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</span><br><span class="line">主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</span><br><span class="line">在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</span><br></pre></td></tr></table></figure><h3 id="主从-同步原理"><a href="#主从-同步原理" class="headerlink" title="主从 - 同步原理"></a>主从 - 同步原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</span><br><span class="line"></span><br><span class="line">在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</span><br><span class="line"></span><br><span class="line">另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</span><br><span class="line"></span><br><span class="line">主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</span><br><span class="line"></span><br><span class="line">增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</span><br></pre></td></tr></table></figure><h3 id="sentinel介绍"><a href="#sentinel介绍" class="headerlink" title="sentinel介绍"></a><strong>sentinel介绍</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Sentinel(哨兵)是用于监控redis集群中Master状态的工具，其已经被集成在redis2.4+的版本中</span><br><span class="line">Sentinel作用： </span><br><span class="line">1)：Master状态检测 </span><br><span class="line">2)：如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave </span><br><span class="line">3)：Master-Slave切换后，master_redis.conf、slave_redis.conf和sentinel.conf的内容都会发生改变，即master_redis.conf中会多一行slaveof的配置，sentinel.conf的监控目标会随之调换 </span><br><span class="line">Sentinel工作方式： </span><br><span class="line">1)：每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令 </span><br><span class="line">2)：如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。 </span><br><span class="line">3)：如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </span><br><span class="line">4)：当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 </span><br><span class="line">5)：在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 </span><br><span class="line">6)：当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 </span><br><span class="line">7)：若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </span><br><span class="line">若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</span><br><span class="line">=============================================================</span><br><span class="line">主观下线和客观下线 </span><br><span class="line">主观下线：Subjectively Down，简称 SDOWN，指的是当前 Sentinel 实例对某个redis服务器做出的下线判断。 </span><br><span class="line">客观下线：Objectively Down， 简称 ODOWN，指的是多个 Sentinel 实例在对Master Server做出 SDOWN  判断，并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后，得出的Master  Server下线判断，然后开启failover.</span><br></pre></td></tr></table></figure><h3 id="主从同步部署"><a href="#主从同步部署" class="headerlink" title="主从同步部署"></a>主从同步部署</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试环境:centos7.4</span><br><span class="line">redis-master:192.168.19.129   vm1</span><br><span class="line">redis-slave1:192.168.19.136   vm4</span><br><span class="line">redis-slave2:192.168.19.135   vm3</span><br><span class="line">1.首先三台服务器将redis单机部署完成。</span><br><span class="line">编辑master的redis配置文件:</span><br><span class="line">[root@redis-master ~]# cd /usr/local/redis-4.0.9</span><br><span class="line">[root@redis-master redis]# vim redis.conf</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/05/07/5cd19e2caa3bf.jpg" /><p>2.修改slave1的配置文件：<br>[root@redis-slave1 ~]# cd /data/application/redis/<br>[root@redis-slave1 redis]# vim redis.conf      —修改如下：</p><img src="https://i.loli.net/2019/05/07/5cd19e5ea0f84.jpg" /><img src="https://i.loli.net/2019/05/07/5cd19e838e43e.jpg" /><p>3.配置slave2的配置文件:<br>[root@redis-slave2 ~]# cd /data/application/redis/<br>[root@redis-slave2 redis]# vim redis.conf       —修改如下  和slave1 相同</p><p>4.重启三台redis</p><img src="https://i.loli.net/2019/05/07/5cd19ebbe787b.jpg" /><p>5.测试主从</p><img src="https://i.loli.net/2019/05/07/5cd19f3641529.jpg" /><p><img src="C:%5CUsers%5Cw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557241701339.png" alt="1557241701339"></p><p>三台均测试无误，主从同步部署完成</p><h3 id="配置哨兵模式"><a href="#配置哨兵模式" class="headerlink" title="配置哨兵模式"></a>配置哨兵模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.每台机器上修改redis主配置文件redis.conf文件设置：bind 0.0.0.0       ---配置主从时已经完成</span><br><span class="line">2.每台机器上修改sentinel.conf配置文件：修改如下配置</span><br><span class="line">[root@redis-master src]# cd ..</span><br><span class="line">[root@redis-master redis]# vim sentinel.conf</span><br><span class="line">        sentinel monitor mymaster 192.168.19.129 6379 2 (slave上面写的是master的ip，master写自己ip)</span><br><span class="line">        sentinel down-after-milliseconds mymaster 3000</span><br><span class="line">        sentinel failover-timeout mymaster 10000</span><br><span class="line">        protected-mode no</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">关闭加密</span><br><span class="line">protected-mode no</span><br><span class="line">构成master客观下线的前提，至少有两个sentinel(哨兵)主观认为master已经下线</span><br><span class="line">sentinel monitor mymaster 192.168.19.129 6379 2 </span><br><span class="line">sentinel每隔一定时间向其已知的master发送ping指令，在设置的这个时间内如果没有收master返回的数据包，就会把master标记为主观下线。单位为毫秒</span><br><span class="line">sentinel down-after-milliseconds mymaster 3000</span><br><span class="line">在这个时间内如果主从切换没有完成就停止切换。单位毫秒</span><br><span class="line">sentinel failover-timeout mymaster 10000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">3.每台机器启动哨兵服务：</span><br><span class="line">        # ./src/redis-sentinel sentinel.conf</span><br><span class="line">注意:在生产环境下将哨兵模式启动放到后台执行:    nohup     ./src/redis-sentinel sentinel.conf &amp;</span><br><span class="line">在master上面执行</span><br><span class="line">这是启动成功的！</span><br><span class="line">然后再从配置文件中看</span><br><span class="line">vim redis.conf</span><br><span class="line">vim sentinel.conf</span><br></pre></td></tr></table></figure><img src="https://i.loli.net/2019/05/07/5cd1a228086b6.jpg" /><img src="https://i.loli.net/2019/05/07/5cd1a2797a3e7.jpg" /><p>将master的哨兵模式退出，再将redis服务stop了，在两台slave上面查看其中一台是否切换为master:(没有优先级，为随机切换)</p><p>master 192.168.19.129</p><img src="https://i.loli.net/2019/05/07/5cd1a2ef82487.jpg" /><p>slave 192.168.19.136</p><p><img src="C:%5CUsers%5Cw%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1557242911037.png" alt="1557242911037"></p><p>​               主从+哨兵模式测试部署完成！</p><p>==========================================================</p><p>了解</p><p>主从+哨兵+lvs  制作redis主从的高科用</p><p>redis切片等</p><p><img src="https://i.loli.net/2019/09/10/7kS4CQ9Pypv2TxN.jpg" alt=""></p><p><img src="https://i.loli.net/2019/09/10/XCz17HKP4iTfAhu.jpg" alt=""></p><p><img src="https://i.loli.net/2019/09/10/VmFP6Skp4TRHudx.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/31/hello-world/"/>
      <url>/2019/10/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
